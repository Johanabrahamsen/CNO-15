import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.ParseTreeProperty;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

public class ByteCodeWriter {

    private static final ArrayList<String> errors = new ArrayList<>();

    /**
     * Bytecode from Maximus can be generated by entering a string into the "generateByteCode" method in main.
     * There have been 5 good weather and 5 bad weather programs prepared, these can be entered by calling "getGoodProgram"
     * or "getBadProgram" along with a number from 0-4 to choose different programs.
     * once a good weather piece of code has been generated it can be run by entering "java -jar ./lib/jasmin.jar test.j" first
     * followed by "java test"
     * @param args
     */

    public static void main(String[] args) {

        generateByteCode(getGoodProgram(1));

    }

    public static String getGoodProgram(int program){
        String[] programs = new String[5];
        programs[0] = "BEGIN{num a is 20$" +
                "arr c{5,num}$" +
                "c[0] is a$" +
                "show(c[0])$}";
        programs[1] = "BEGIN{booly a is invalid$" +
                "num b is 1$" +
                "doOn(a equals invalid){" +
                "loop[5]times{" +
                "b is (b add 1)$ " +
                "show(b)$" +
                "condition(b bigger 12){" +
                "a is valid$}}}}";
        programs[2] = "BEGIN{loop[9]times{" +
                "show(1000)$}}";
        programs[3] ="BEGIN{num a is 4$" +
                "condition(a equals 3){" +
                "show(1)$}" +
                "condition(a equals 4){" +
                "show(2)$}" +
                "condition(a equals 5){" +
                "show(3)$}}";
        programs[4] ="BEGIN{num a is 4$" +
                "condition(a bigger 3){" +
                "show(1)$}" +
                "condition(a equals 4){" +
                "show(2)$}" +
                "condition(a smaller 5){" +
                "show(3)$}}";
        return programs[program];
    }

    public static String getBadProgram(int program) {
        String[] programs = new String[5];
        //program 0: out of scope example
        programs[0] = "BEGIN{num a is 5$" +
                "condition(a equals 5){" +
                "num b is 6$" +
                "a is b$}" +
                "show(b)$}";
        //program 1: "is" is only used to assign, for comparison use "equals"
        programs[1] = "BEGIN{num a is 5$" +
                "condition(a is 5){" +
                "num b is 6$" +
                "a is b$}}";
        //program 2: doubles can not be assigned to variables with type int
        programs[2] = "BEGIN{num a is 5$" +
                "condition(a is 5){" +
                "numnum b is 6.0$" +
                "a is b$}}";
        //program 3: booleans are not allowed to be stored in array of type int
        programs[3] = "BEGIN{num a is 20$" +
                "arr c{5,num}$" +
                "c[0] is valid$" +
                "show(c[0])$}";
        //program 4: no value can be entered in an array with index out of bounds
        programs[4] = "BEGIN{num a is 20$" +
                "arr c{5,num}$" +
                "c[5] is a$" +
                "show(c[0])$}";
        return programs[program];
    }

    private static void generateByteCode(String line) {
        ByteCode b = new ByteCode("Test");
        ParseTreeProperty<DataType> types = new ParseTreeProperty<>();
        ParseTreeProperty<SymbolTable> symbols = new ParseTreeProperty<>();
        CodeGenerator c = new CodeGenerator(symbols, types, b);

        // Reset errors
        errors.clear();

        // Create lexer and run scanner to create stream of tokens
        CharStream charStream = CharStreams.fromString(line);
        MaximusLexer lexer = new MaximusLexer(charStream);
        setupErrorListener(lexer);
        CommonTokenStream tokens = new CommonTokenStream(lexer);

        // Create parser and feed it the tokens
        MaximusParser parser = new MaximusParser(tokens);
        setupErrorListener(parser);
        MaximusParser.ProgramContext parseTree = parser.program();
        SymbolTable symbolTable = new SymbolTable(1);

        Checker checker = new Checker(types,symbols,symbolTable);
        try{
            checker.visit(parseTree);
        } catch (CompilerException e){
            System.err.println(e.getMessage());
        }


        // Have there been errors? Bail out
        if (errors.size() > 0) {
            for (String e : errors)
                System.out.println(e);
            return;
        }

        // Generate code
        c.visit(parseTree);

        try {
            // Write to file
            PrintWriter out = new PrintWriter(new File("test.j"));

            out.println(".class public test");
            out.println(".super java/lang/Object");
            out.println("");

            // Main method
            out.println(".method public static main([Ljava/lang/String;)V");
            out.println(".limit stack 99");
            out.println(".limit locals 99");
            out.println("");

            for( String codeLine : b.getJasminCode() )
                out.println(codeLine);

            out.println("return");
            out.println(".end method");

            out.close();
        } catch( IOException error ) {
            System.err.println("Error writing file: " + error.getMessage() );
        }
    }
    private static void setupErrorListener( Recognizer<?, ?> lexerOrParser ) {
        lexerOrParser.removeErrorListeners();
        lexerOrParser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol,
                                    int line, int charPositionInLine,
                                    String msg, RecognitionException e ) {
                errors.add( "ERROR at pos " + charPositionInLine + ": " + msg );
            }
        });
    }
}
